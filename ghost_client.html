<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- å¼ºåˆ¶ç¦ç”¨ç¼“å­˜ -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Ghost Shell - AI è¿œç¨‹æ§åˆ¶</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background: #16213e;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #0f3460;
        }

        h1 {
            font-size: 1.2rem;
            color: #00d9ff;
        }

        .status {
            font-size: 0.85rem;
            padding: 6px 12px;
            border-radius: 20px;
        }

        .status.connected {
            background: #0f3460;
            color: #00ff88;
        }

        .status.disconnected {
            background: #3d0000;
            color: #ff4444;
        }

        main {
            flex: 1;
            display: flex;
            padding: 15px;
            gap: 15px;
        }

        .screen-container {
            flex: 1;
            background: #0f0f23;
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        #screen {
            max-width: 100%;
            max-height: calc(100vh - 120px);
            cursor: crosshair;
        }

        .controls {
            width: 260px;
            background: #16213e;
            border-radius: 12px;
            padding: 14px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
        }

        .control-group {
            margin-bottom: 4px;
        }

        .control-group label {
            display: block;
            margin-bottom: 4px;
            color: #888;
            font-size: 0.75rem;
        }

        input,
        button,
        select {
            width: 100%;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            font-size: 0.85rem;
        }

        input,
        select {
            background: #0f0f23;
            color: #fff;
            border: 1px solid #0f3460;
        }

        input:focus,
        select:focus {
            outline: none;
            border-color: #00d9ff;
        }

        button {
            background: linear-gradient(135deg, #0f3460, #16213e);
            color: #00d9ff;
            cursor: pointer;
            border: 1px solid #0f3460;
            transition: all 0.2s;
        }

        button:hover {
            background: #0f3460;
        }

        button.primary {
            background: linear-gradient(135deg, #00d9ff, #0066ff);
            color: #fff;
            border: none;
        }

        button.danger {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: #fff;
            border: none;
        }

        .log {
            flex: 1;
            background: #0f0f23;
            border-radius: 6px;
            padding: 8px;
            font-family: monospace;
            font-size: 0.7rem;
            overflow-y: auto;
            max-height: 150px;
            color: #00ff88;
        }

        .log-entry {
            margin: 2px 0;
        }

        .log-entry.error {
            color: #ff4444;
        }

        .fps {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.7);
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 0.65rem;
        }

        .window-info {
            font-size: 0.7rem;
            color: #888;
            margin-top: 4px;
        }

        .locked {
            color: #00ff88;
        }

        @media (max-width: 800px) {
            main {
                flex-direction: column;
            }

            .controls {
                width: 100%;
                max-height: 300px;
            }
        }

        /* Touch ripple animation */
        @keyframes ripple {
            0% {
                transform: scale(0.5);
                opacity: 1;
            }

            100% {
                transform: scale(2);
                opacity: 0;
            }
        }
    </style>
</head>

<body>
    <header>
        <h1>ğŸ”® Ghost Shell</h1>
        <div id="status" class="status disconnected">æœªè¿æ¥</div>
    </header>
    <main>
        <div class="screen-container">
            <img id="screen" src="" alt="è¿œç¨‹ç”»é¢">
            <div class="fps" id="fps">0 FPS</div>
        </div>
        <div class="controls">
            <!-- Row 1: Voice + Fullscreen + Adapt -->
            <div style="display: flex; gap: 6px;">
                <button id="voiceBtn" onclick="toggleVoice()" class="primary" style="flex: 1; padding: 10px;">
                    ğŸ¤ è¯­éŸ³
                </button>
                <button id="fullscreenBtn" onclick="toggleFullscreen()" style="flex: 1; padding: 10px;">
                    ğŸ”² å…¨å±
                </button>
                <button id="adaptBtn" onclick="toggleAdapt()" style="flex: 1; padding: 10px;">
                    ğŸ“ é€‚é…
                </button>
            </div>

            <!-- Row 2: Window Select + Lock + Close -->
            <div style="display: flex; gap: 6px; margin-top: 6px; align-items: center;">
                <!-- Native Select Dropdown -->
                <select id="windowSelect" onchange="handleWindowSelect()"
                    style="flex: 2; padding: 8px; font-size: 0.85rem;">
                    <option value="">ğŸ” è‡ªåŠ¨æ£€æµ‹...</option>
                </select>

                <button id="lockBtn" onclick="toggleLock()" style="flex: 1; padding: 10px;">
                    ğŸ”’ é”å®š
                </button>

                <!-- Close Current Window Button -->
                <button id="closeBtn" onclick="closeCurrentWindow()"
                    style="flex: 1; padding: 10px; background: #661111; border: 1px solid #ff4444; color: #ff6b6b; cursor: pointer; border-radius: 4px; font-size: 0.85rem;"
                    title="å…³é—­å½“å‰çª—å£">
                    âœ• å…³é—­
                </button>
            </div>

            <!-- Hidden input for keyboard capture -->
            <input type="text" id="hiddenKeyboardInput" style="position: absolute; left: -9999px; opacity: 0;"
                oninput="onRealtimeInput(event)" onkeydown="onRealtimeKeyDown(event)" onblur="onKeyboardBlur()"
                autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">

            <!-- Touch hints for mobile -->
            <div style="font-size: 0.65rem; color: #666; text-align: center; margin: 8px 0;">
                ğŸ“± ç‚¹å‡»=å·¦é”® | åŒå‡»=å³é”® | å¿«æ»‘=æ»šåŠ¨ | æŒ‰ä½æ‹–=è¿ç»­æ»š | åŒæŒ‡=ç¼©æ”¾
            </div>

            <!-- Collapsible advanced section -->
            <details style="margin-top: 8px;">
                <summary style="cursor: pointer; color: #00d9ff; font-size: 0.85rem;">âš™ï¸ æ›´å¤šé€‰é¡¹</summary>

                <div style="margin-top: 10px;">

                    <!-- App Launcher -->
                    <div class="control-group" style="margin-top: 12px;">
                        <label>ğŸš€ å¿«é€Ÿå¯åŠ¨</label>
                        <input type="text" id="appInput" placeholder="è¾“å…¥è½¯ä»¶å (å¦‚: chrome)"
                            onkeydown="if(event.key==='Enter')openApp()">
                    </div>
                    <button onclick="openApp()">æ‰“å¼€è½¯ä»¶</button>

                    <!-- FPS Control -->
                    <div class="control-group" style="margin-top: 12px;">
                        <label>å¸§ç‡: <span id="fpsValue">30</span> FPS</label>
                        <input type="range" id="fpsSlider" min="5" max="60" value="30"
                            oninput="updateFpsTarget(this.value)" style="width: 100%;">
                    </div>
                </div>
            </details>

            <!-- Compact log -->
            <div class="control-group" style="margin-top: 8px;">
                <div class="log" id="log" style="max-height: 80px; font-size: 0.65rem;"></div>
            </div>

            <!-- Current window indicator -->
            <div class="window-info" style="font-size: 0.7rem; text-align: center;">
                å½“å‰: <span id="currentWindow">-</span>
            </div>
        </div>
    </main>
    <script>
        let ws = null;
        let frameCount = 0;
        let lastFpsTime = Date.now();
        let windowRefreshTimer = null;  // çª—å£åˆ—è¡¨è‡ªåŠ¨åˆ·æ–°å®šæ—¶å™¨
        let serverWindowWidth = 0;      // æœåŠ¡ç«¯å‘é€çš„çª—å£å®½åº¦
        let serverWindowHeight = 0;     // æœåŠ¡ç«¯å‘é€çš„çª—å£é«˜åº¦
        const screen = document.getElementById('screen');
        const status = document.getElementById('status');
        const log = document.getElementById('log');
        const fpsDisplay = document.getElementById('fps');
        const serverInput = null; // Removed server input

        // Auto-detect server URL
        // Prefer 127.0.0.1 over localhost to avoid IPv6 issues
        let hostname = window.location.hostname || 'localhost';
        if (hostname === 'localhost') hostname = '127.0.0.1';

        const API = `http://${hostname}:8000`; // Not using window.location.host so we can force IP if needed

        function addLog(msg, isError = false) {
            const entry = document.createElement('div');
            entry.className = 'log-entry' + (isError ? ' error' : '');
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
            if (log.children.length > 50) log.removeChild(log.firstChild);
        }

        // Speech Recognition Setup
        let recognition = null;
        let isListening = false;

        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = true;
            recognition.lang = 'zh-CN'; // Chinese language

            recognition.onstart = () => {
                isListening = true;
                document.getElementById('voiceBtn').textContent = 'ğŸ”´ æ­£åœ¨å¬...';
                document.getElementById('voiceBtn').classList.add('danger');
                addLog('è¯­éŸ³è¯†åˆ«å·²å¯åŠ¨ï¼Œè¯·è¯´è¯...');
            };

            recognition.onresult = (event) => {
                let transcript = '';
                for (let i = 0; i < event.results.length; i++) {
                    transcript += event.results[i][0].transcript;
                }
                document.getElementById('textInput').value = transcript;

                // If result is final, auto-send
                if (event.results[event.results.length - 1].isFinal) {
                    addLog(`è¯†åˆ«ç»“æœ: "${transcript}"`);
                }
            };

            recognition.onend = () => {
                isListening = false;
                document.getElementById('voiceBtn').textContent = 'ğŸ¤ è¯­éŸ³è¾“å…¥';
                document.getElementById('voiceBtn').classList.remove('danger');
            };

            recognition.onerror = (event) => {
                addLog('è¯­éŸ³è¯†åˆ«é”™è¯¯: ' + event.error, true);
                isListening = false;
                document.getElementById('voiceBtn').textContent = 'ğŸ¤ è¯­éŸ³è¾“å…¥';
                document.getElementById('voiceBtn').classList.remove('danger');
            };
        }

        function toggleVoice() {
            if (!recognition) {
                addLog('æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«', true);
                return;
            }

            if (isListening) {
                recognition.stop();
            } else {
                recognition.start();
            }
        }

        function toggleConnection() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            } else {
                connect();
            }
        }

        function connect() {
            // Auto-detect server URL
            let host = window.location.hostname;

            // Fallback for file:// or empty -> use IPv4 loopback
            if (!host || host === 'localhost') {
                host = '127.0.0.1';
                if (window.location.protocol === 'file:') {
                    addLog('æ£€æµ‹åˆ°æœ¬åœ°æ–‡ä»¶è¿è¡Œï¼Œç›´è¿ 127.0.0.1');
                }
            }

            // If we are on network IP, use it. If hostname is blank (file://), use 127.0.0.1
            // Use 8000 port explicitly

            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const url = `${protocol}//${host}:8000/stream`;

            addLog('æ­£åœ¨è¿æ¥ ' + url);

            try {
                ws = new WebSocket(url);

                ws.onopen = () => {
                    status.textContent = 'å·²è¿æ¥';
                    status.className = 'status connected';
                    status.onclick = toggleConnection;
                    addLog('è¿æ¥æˆåŠŸ!');
                    refreshWindows();

                    // å¯åŠ¨çª—å£åˆ—è¡¨è‡ªåŠ¨åˆ·æ–°ï¼ˆæ¯5ç§’ï¼‰
                    if (windowRefreshTimer) clearInterval(windowRefreshTimer);
                    windowRefreshTimer = setInterval(() => {
                        refreshWindowsQuiet();  // é™é»˜åˆ·æ–°ï¼Œä¸æ˜¾ç¤ºæ—¥å¿—
                    }, 5000);
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data.type === 'frame') {
                        screen.src = 'data:image/jpeg;base64,' + data.data;
                        // ä¿å­˜æœåŠ¡ç«¯å‘é€çš„çª—å£å°ºå¯¸
                        serverWindowWidth = data.width;
                        serverWindowHeight = data.height;
                        frameCount++;
                        updateFps();
                    } else if (data.type === 'error') {
                        addLog('é”™è¯¯: ' + data.message, true);
                    }
                };

                ws.onclose = () => {
                    status.textContent = 'æœªè¿æ¥ (ç‚¹å‡»é‡è¿)';
                    status.className = 'status disconnected';
                    status.onclick = toggleConnection;
                    addLog('å·²æ–­å¼€');
                    // åœæ­¢çª—å£åˆ—è¡¨è‡ªåŠ¨åˆ·æ–°
                    if (windowRefreshTimer) {
                        clearInterval(windowRefreshTimer);
                        windowRefreshTimer = null;
                    }
                };

                ws.onerror = (e) => {
                    addLog('WebSocketé”™è¯¯. è¯·æ£€æŸ¥æœåŠ¡æ˜¯å¦å¼€å¯.', true);
                };
            } catch (err) {
                addLog('åˆ›å»ºè¿æ¥å¤±è´¥: ' + err, true);
            }
        }

        function updateFps() {
            const now = Date.now();
            if (now - lastFpsTime >= 1000) {
                fpsDisplay.textContent = frameCount + ' FPS';
                frameCount = 0;
                lastFpsTime = now;
            }
        }

        // ==================== Window Selection Logic ====================

        // Update close button text based on current window
        function updateCloseButton() {
            const closeBtn = document.getElementById('closeBtn');
            const select = document.getElementById('windowSelect');
            const currentWindow = document.getElementById('currentWindow').textContent;

            // Get window title (priority: select value > locked window)
            let windowTitle = select.value;
            if (!windowTitle && currentWindow && currentWindow !== 'æœªæ‰¾åˆ°' && currentWindow !== '-') {
                windowTitle = currentWindow.replace('ğŸ”’ ', '').trim();
            }

            if (windowTitle) {
                // Show window name in button (truncate if too long)
                const shortName = windowTitle.length > 12 ? windowTitle.substring(0, 12) + '...' : windowTitle;
                closeBtn.textContent = `âœ• ${shortName}`;
                closeBtn.disabled = false;
                closeBtn.style.opacity = '1';
                closeBtn.title = `å…³é—­çª—å£: ${windowTitle}`;
            } else {
                // No window selected
                closeBtn.textContent = 'âœ• å…³é—­';
                closeBtn.disabled = true;
                closeBtn.style.opacity = '0.5';
                closeBtn.title = 'è¯·å…ˆé€‰æ‹©ä¸€ä¸ªçª—å£';
            }
        }

        async function refreshWindows() {
            try {
                const res = await fetch(`${API}/windows`);
                const data = await res.json();

                // Populate native select
                const select = document.getElementById('windowSelect');
                const currentValue = select.value;  // ä¿å­˜å½“å‰é€‰ä¸­å€¼
                select.innerHTML = '<option value="">ğŸ” è‡ªåŠ¨æ£€æµ‹...</option>';
                data.windows.forEach(w => {
                    const option = document.createElement('option');
                    option.value = w.title;
                    option.textContent = `${w.title} (${w.size})`;
                    select.appendChild(option);
                });

                // Update current window display
                document.getElementById('currentWindow').textContent = data.current || 'æœªæ‰¾åˆ°';
                const lockBtn = document.getElementById('lockBtn');
                if (data.locked) {
                    select.value = data.locked;
                    document.getElementById('currentWindow').innerHTML = `<span class="locked">ğŸ”’ ${data.locked}</span>`;
                    lockBtn.textContent = 'ğŸ”“ è§£é”';
                    lockBtn.className = 'danger';
                } else {
                    select.value = '';
                    lockBtn.textContent = 'ğŸ”’ é”å®š';
                    lockBtn.className = '';
                }
                // Update close button
                updateCloseButton();

                addLog(`æ‰¾åˆ° ${data.windows.length} ä¸ªçª—å£`);
            } catch (e) {
                addLog('åˆ·æ–°çª—å£å¤±è´¥: ' + e, true);
            }
        }

        // é™é»˜åˆ·æ–°çª—å£åˆ—è¡¨ï¼ˆä¸æ˜¾ç¤ºæ—¥å¿—ï¼‰
        async function refreshWindowsQuiet() {
            try {
                const res = await fetch(`${API}/windows`);
                const data = await res.json();

                const select = document.getElementById('windowSelect');
                const currentValue = select.value;  // ä¿å­˜å½“å‰é€‰ä¸­å€¼
                select.innerHTML = '<option value="">ğŸ” è‡ªåŠ¨æ£€æµ‹...</option>';
                data.windows.forEach(w => {
                    const option = document.createElement('option');
                    option.value = w.title;
                    option.textContent = `${w.title} (${w.size})`;
                    select.appendChild(option);
                });

                // æ¢å¤ä¹‹å‰çš„é€‰ä¸­å€¼ï¼ˆå¦‚æœè¿˜å­˜åœ¨ï¼‰
                if (currentValue && Array.from(select.options).some(o => o.value === currentValue)) {
                    select.value = currentValue;
                }

                // Update current window display
                const lockBtn = document.getElementById('lockBtn');
                if (data.locked) {
                    select.value = data.locked;
                    document.getElementById('currentWindow').innerHTML = `<span class="locked">ğŸ”’ ${data.locked}</span>`;
                    lockBtn.textContent = 'ğŸ”“ è§£é”';
                    lockBtn.className = 'danger';
                } else {
                    document.getElementById('currentWindow').textContent = data.current || 'æœªæ‰¾åˆ°';
                    lockBtn.textContent = 'ğŸ”’ é”å®š';
                    lockBtn.className = '';
                }
                updateCloseButton();
            } catch (e) {
                // é™é»˜å¤±è´¥ï¼Œä¸æ˜¾ç¤ºé”™è¯¯
            }
        }

        async function handleWindowSelect() {
            const select = document.getElementById('windowSelect');
            const title = select.value;

            if (title === '') {
                // é€‰æ‹©"è‡ªåŠ¨æ£€æµ‹" -> è§£é”ï¼Œæ¢å¤è‡ªåŠ¨è·Ÿéš
                await unlockWindow();
            } else {
                // é€‰æ‹©äº†å…·ä½“çª—å£ -> é”å®šåˆ°è¯¥çª—å£
                await lockWindow(title);
            }
        }

        async function closeCurrentWindow() {
            const select = document.getElementById('windowSelect');
            let title = select.value;  // ä¼˜å…ˆä½¿ç”¨é€‰ä¸­çš„å€¼

            console.log('[DEBUG] Close window - select.value:', title);

            // å¦‚æœæ²¡æœ‰é€‰ä¸­ï¼Œå°è¯•ä»å½“å‰çª—å£è·å–ï¼ˆä½†è¦æ¸…ç†æ ¼å¼ï¼‰
            if (!title) {
                const currentText = document.getElementById('currentWindow').textContent;
                console.log('[DEBUG] Close window - currentWindow text:', currentText);
                if (currentText && currentText !== 'æœªæ‰¾åˆ°' && currentText !== '-' && currentText !== 'è‡ªåŠ¨è·Ÿéšä¸­...') {
                    title = currentText.replace('ğŸ”’ ', '').trim();
                }
            }

            console.log('[DEBUG] Close window - final title:', title);

            // æœ€ç»ˆéªŒè¯
            if (!title || title === 'æœªæ‰¾åˆ°' || title === '-' || title === '' || title === 'è‡ªåŠ¨è·Ÿéšä¸­...') {
                addLog('âŒ è¯·å…ˆé€‰æ‹©è¦å…³é—­çš„çª—å£', true);
                return;
            }

            // ç›´æ¥å…³é—­ï¼Œä¸å¼¹çª—ç¡®è®¤ï¼ˆé¿å…å…¨å±æ¨¡å¼è¢«é€€å‡ºï¼‰
            try {
                addLog(`âš ï¸ æ­£åœ¨å…³é—­: ${title.substring(0, 30)}...`);

                // ä¸ºäº†ç¡®ä¿å…³é—­æ­£ç¡®çš„çª—å£ï¼Œå…ˆé”å®šåˆ°è¯¥çª—å£
                await fetch(`${API}/lock`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title: title })
                });

                // çŸ­æš‚å»¶è¿Ÿç¡®ä¿é”å®šç”Ÿæ•ˆ
                await new Promise(resolve => setTimeout(resolve, 200));

                // å‘é€å…³é—­å‘½ä»¤
                const res = await fetch(`${API}/interact`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'close_window' })
                });
                const data = await res.json();

                if (data.status === 'success') {
                    addLog(`âœ… ${data.message}`);
                } else {
                    addLog('æ“ä½œç»“æœ: ' + (data.message || 'æœªçŸ¥çŠ¶æ€'));
                }

                // å…³é—­æˆåŠŸåï¼Œè‡ªåŠ¨è§£é”æ¢å¤è‡ªåŠ¨è·Ÿéšæ¨¡å¼
                await new Promise(resolve => setTimeout(resolve, 300));
                await unlockWindow();
                addLog('å·²åˆ‡æ¢åˆ°è‡ªåŠ¨è·Ÿéšæ¨¡å¼');

            } catch (e) {
                console.error('[ERROR] Close window failed:', e);
                addLog('å…³é—­çª—å£å¤±è´¥: ' + e, true);
                // å³ä½¿å¤±è´¥ä¹Ÿå°è¯•è§£é”ï¼Œé¿å…å¡åœ¨å·²å…³é—­çš„çª—å£
                await unlockWindow();
            }
        }

        // å‘é€è§£é”è¯·æ±‚ï¼ˆæ¢å¤è‡ªåŠ¨è·Ÿéšï¼‰
        async function unlockWindow() {
            const lockBtn = document.getElementById('lockBtn');
            const select = document.getElementById('windowSelect');

            try {
                const res = await fetch(`${API}/lock`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title: '' })
                });
                const data = await res.json();
                addLog(data.message || 'å·²æ¢å¤è‡ªåŠ¨è·Ÿéš');

                // æ›´æ–° UI
                lockBtn.textContent = 'ğŸ”’ é”å®š';
                lockBtn.className = '';
                select.value = '';
                document.getElementById('currentWindow').textContent = 'è‡ªåŠ¨è·Ÿéšä¸­...';

                await refreshWindows();
            } catch (e) {
                addLog('è§£é”å¤±è´¥: ' + e, true);
            }
        }

        async function closeWindowByTitle(title) {
            if (!confirm(`ç¡®å®šè¦å…³é—­ \"${title.substring(0, 30)}...\" å—ï¼Ÿ`)) return;
            try {
                // First lock to target, then close
                await fetch(`${API}/lock`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title })
                });
                const res = await fetch(`${API}/interact`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'close_window', x: 0, y: 0 })
                });
                const data = await res.json();
                if (data.status === 'closed') {
                    addLog(`âœ… å·²å…³é—­: ${title.substring(0, 20)}...`);
                } else {
                    addLog('å…³é—­å¤±è´¥: ' + (data.message || ''), true);
                }
                setTimeout(refreshWindows, 1000);
            } catch (e) {
                addLog('å…³é—­å¤±è´¥: ' + e, true);
            }
        }

        async function lockWindow(title) {
            if (!title) {
                addLog('è¯·å…ˆé€‰æ‹©çª—å£', true);
                return;
            }

            const lockBtn = document.getElementById('lockBtn');

            try {
                const res = await fetch(`${API}/lock`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title })
                });
                const data = await res.json();
                addLog(data.message || 'å·²é”å®š');

                // å¼ºåˆ¶æ›´æ–° UI
                lockBtn.textContent = 'ğŸ”“ è§£é”';
                lockBtn.className = 'danger';
                document.getElementById('windowSelect').value = title;

                // åˆ·æ–°çª—å£åˆ—è¡¨
                await refreshWindows();
            } catch (e) {
                addLog('é”å®šå¤±è´¥: ' + e, true);
            }
        }

        // ä¸€é”®é”å®šå½“å‰çª—å£ / è§£é”æ¢å¤è‡ªåŠ¨è·Ÿéš
        async function toggleLock() {
            const lockBtn = document.getElementById('lockBtn');
            const isCurrentlyLocked = lockBtn.textContent.includes('è§£é”');

            if (isCurrentlyLocked) {
                // å½“å‰å·²é”å®š -> æ‰§è¡Œè§£é”ï¼ˆæ¢å¤è‡ªåŠ¨è·Ÿéšï¼‰
                await unlockWindow();
            } else {
                // å½“å‰æœªé”å®š -> ä¸€é”®é”å®šå½“å‰æ­£åœ¨æ˜¾ç¤ºçš„çª—å£
                try {
                    const res = await fetch(`${API}/lock_current`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    const data = await res.json();

                    if (data.status === 'locked') {
                        addLog(`âœ… ${data.message}`);
                        lockBtn.textContent = 'ğŸ”“ è§£é”';
                        lockBtn.className = 'danger';
                        document.getElementById('currentWindow').innerHTML =
                            `<span class="locked">ğŸ”’ ${data.title}</span>`;
                        document.getElementById('windowSelect').value = data.title;
                    } else {
                        addLog('é”å®šå¤±è´¥: ' + (data.message || 'æœªçŸ¥é”™è¯¯'), true);
                    }

                    await refreshWindows();
                } catch (e) {
                    addLog('é”å®šå¤±è´¥: ' + e, true);
                }
            }
        }

        screen.onclick = async (e) => {
            const rect = screen.getBoundingClientRect();

            // ä½¿ç”¨æœåŠ¡ç«¯å‘é€çš„çª—å£å°ºå¯¸ï¼ˆè¿™æ˜¯ç‚¹å‡»åæ ‡çš„ç›®æ ‡å°ºå¯¸ï¼‰
            const winW = serverWindowWidth || screen.naturalWidth;
            const winH = serverWindowHeight || screen.naturalHeight;

            // è®¡ç®—ç‚¹å‡»åœ¨æ˜¾ç¤ºå›¾åƒä¸Šçš„ç›¸å¯¹ä½ç½®ï¼ˆ0-1èŒƒå›´ï¼‰
            const relX = (e.clientX - rect.left) / rect.width;
            const relY = (e.clientY - rect.top) / rect.height;

            // è½¬æ¢ä¸ºçª—å£åæ ‡
            const x = Math.round(relX * winW);
            const y = Math.round(relY * winH);

            addLog(`ç‚¹å‡» (${x}, ${y})`);
            try {
                const res = await fetch(`${API}/interact`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'click', x, y })
                });
                const data = await res.json();
                addLog('å·²ç‚¹å‡»');
            } catch (e) {
                addLog('ç‚¹å‡»å¤±è´¥: ' + e, true);
            }
        };

        // ==================== Fullscreen & Adapt ====================
        let isAdapted = false;  // Track adaptation state

        function toggleFullscreen() {
            const doc = document.documentElement;
            if (!document.fullscreenElement) {
                doc.requestFullscreen().then(() => {
                    document.getElementById('fullscreenBtn').textContent = 'ğŸ”² é€€å‡º';
                    addLog('å·²è¿›å…¥å…¨å±');
                }).catch(e => addLog('å…¨å±å¤±è´¥: ' + e, true));
            } else {
                document.exitFullscreen().then(() => {
                    document.getElementById('fullscreenBtn').textContent = 'ğŸ”² å…¨å±';
                    addLog('å·²é€€å‡ºå…¨å±');
                });
            }
        }

        async function toggleAdapt() {
            const action = isAdapted ? 'restore_window' : 'adapt_phone';
            try {
                const res = await fetch(`${API}/interact`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: action, text: '', x: 0, y: 0 })
                });
                const data = await res.json();
                if (data.status === 'adapted') {
                    isAdapted = true;
                    document.getElementById('adaptBtn').textContent = 'ğŸ“ æ¢å¤';
                    addLog(`âœ… å·²é€‚é…: ${data.size[0]}x${data.size[1]}`);
                } else if (data.status === 'restored') {
                    isAdapted = false;
                    document.getElementById('adaptBtn').textContent = 'ğŸ“ é€‚é…';
                    addLog('âœ… å·²æ¢å¤åŸçª—å£');
                } else {
                    addLog('å¤±è´¥: ' + (data.message || JSON.stringify(data)), true);
                }
            } catch (e) {
                addLog('æ“ä½œå¤±è´¥: ' + e, true);
            }
        }


        // ==================== Real-time Keyboard Input ====================
        let lastInputValue = '';  // Track previous value for change detection

        function toggleKeyboard() {
            const hiddenInput = document.getElementById('hiddenKeyboardInput');
            // Always open keyboard
            hiddenInput.focus();
            lastInputValue = '';
            hiddenInput.value = '';
            addLog('é”®ç›˜å·²æ‰“å¼€');
        }

        function onKeyboardBlur() {
            // Keyboard closed by user (no action needed)
        }

        async function onRealtimeInput(event) {
            const input = event.target;
            const newValue = input.value;

            // Detect what changed
            if (newValue.length > lastInputValue.length) {
                // Characters added - send the new characters
                const addedChars = newValue.substring(lastInputValue.length);
                await sendCharacters(addedChars);
            }
            // Note: deletions are handled in onRealtimeKeyDown

            lastInputValue = newValue;
        }

        async function onRealtimeKeyDown(event) {
            if (event.key === 'Backspace') {
                // Let the browser handle the textbox, but also send to PC
                await sendBackspace();
            } else if (event.key === 'Enter') {
                event.preventDefault();  // Don't add newline to textbox
                await sendEnter();
                // Clear the input after Enter
                document.getElementById('textInput').value = '';
                lastInputValue = '';
            }
        }

        async function sendCharacters(chars) {
            if (!chars) return;

            try {
                await fetch(`${API}/interact`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'type', text: chars, x: 0, y: 0 })
                });
                // Show brief feedback
                document.getElementById('keyboardStatus').textContent = `å·²è¾“å…¥: ${chars}`;
                setTimeout(() => {
                    document.getElementById('keyboardStatus').textContent = '(å®æ—¶åŒæ­¥ä¸­)';
                }, 500);
            } catch (e) {
                addLog('è¾“å…¥å¤±è´¥: ' + e, true);
            }
        }

        async function sendBackspace() {
            try {
                await fetch(`${API}/interact`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'key', key: 'backspace', x: 0, y: 0 })
                });
                document.getElementById('keyboardStatus').textContent = 'âŒ« åˆ é™¤';
                setTimeout(() => {
                    document.getElementById('keyboardStatus').textContent = '(å®æ—¶åŒæ­¥ä¸­)';
                }, 300);
            } catch (e) {
                addLog('åˆ é™¤å¤±è´¥: ' + e, true);
            }
        }

        async function sendEnter() {
            try {
                await fetch(`${API}/interact`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'key', key: 'enter', x: 0, y: 0 })
                });
                addLog('â†µ å·²å‘é€å›è½¦');
            } catch (e) {
                addLog('å›è½¦å¤±è´¥: ' + e, true);
            }
        }

        // Legacy sendText for compatibility
        async function sendText() {
            const text = document.getElementById('textInput').value;
            if (!text) return;
            await sendCharacters(text);
            document.getElementById('textInput').value = '';
            lastInputValue = '';
        }

        async function openApp() {
            const appName = document.getElementById('appInput').value;
            if (!appName) return;
            addLog(`æ‰“å¼€è½¯ä»¶: "${appName}"`);
            try {
                await fetch(`${API}/interact`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'open_app', text: appName, x: 0, y: 0 })
                });
                addLog('å·²å‘é€å¯åŠ¨å‘½ä»¤');
                document.getElementById('appInput').value = '';
            } catch (e) {
                addLog('å‘½ä»¤å¤±è´¥: ' + e, true);
            }
        }

        async function sendHotkey() {
            const hotkey = document.getElementById('hotkeyInput').value;
            if (!hotkey) return;
            addLog(`å¿«æ·é”®: ${hotkey}`);
            try {
                const res = await fetch(`${API}/interact`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'hotkey', key: hotkey, x: 0, y: 0 })
                });
                addLog('å·²å‘é€');
            } catch (e) {
                addLog('å¿«æ·é”®å¤±è´¥: ' + e, true);
            }
        }

        async function scrollUp() {
            await sendScrollAmount(120);
        }

        async function scrollDown() {
            await sendScrollAmount(-120);
        }

        // FPS control
        async function updateFpsTarget(fps) {
            document.getElementById('fpsValue').textContent = fps;
            try {
                await fetch(`${API}/set_fps`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ fps: parseInt(fps) })
                });
                addLog(`å¸§ç‡: ${fps} FPS`);
            } catch (e) {
                addLog('å¸§ç‡è®¾ç½®å¤±è´¥', true);
            }
        }

        // Touch gesture support for mobile (enhanced)
        let touchStartY = 0;
        let touchStartX = 0;
        let touchStartTime = 0;
        let isScrolling = false; // Flag for scroll mode

        // Double-tap detection for right-click
        let lastTapTime = 0;
        let lastTapX = 0;
        let lastTapY = 0;

        // Pinch zoom variables
        let initialPinchDistance = 0;
        let isPinching = false;
        let lastZoomTime = 0;

        function getPinchDistance(touches) {
            return Math.hypot(
                touches[0].clientX - touches[1].clientX,
                touches[0].clientY - touches[1].clientY
            );
        }

        async function sendZoom(zoomIn) {
            try {
                await fetch(`${API}/interact`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'hotkey', key: zoomIn ? 'ctrl+=' : 'ctrl+-', x: 0, y: 0 })
                });
                addLog(zoomIn ? 'ğŸ” æ”¾å¤§' : 'ğŸ” ç¼©å°');
            } catch (e) {
                console.log('Zoom error', e);
            }
        }

        // Prevent default touch behavior on screen (no page scrolling)
        screen.addEventListener('touchstart', (e) => {
            // e.preventDefault(); // ALLOW default for some things, but mostly we handle it. 
            // Better to prevent default to stop browser scrolling entire page.
            if (e.target !== screen) return; // Only prevent if touching screen area
            e.preventDefault();

            if (e.touches.length === 2) {
                isPinching = true;
                initialPinchDistance = getPinchDistance(e.touches);
                addLog('âœ‹ åŒæŒ‡ç¼©æ”¾');
                return;
            }

            isPinching = false;
            isScrolling = false;
            touchStartY = e.touches[0].clientY;
            touchStartX = e.touches[0].clientX;
            touchStartTime = Date.now();
        }, { passive: false });

        screen.addEventListener('touchmove', (e) => {
            e.preventDefault();

            if (isPinching && e.touches.length === 2) {
                const currentDistance = getPinchDistance(e.touches);
                if (Math.abs(currentDistance - initialPinchDistance) > 50) { // Threshold 50px
                    const now = Date.now();
                    if (now - lastZoomTime > 300) { // Debounce 300ms
                        if (currentDistance > initialPinchDistance) {
                            sendZoom(true);
                        } else {
                            sendZoom(false);
                        }
                        lastZoomTime = now;
                        initialPinchDistance = currentDistance; // Reset reference
                    }
                }
                return;
            }

            if (e.touches.length === 1) {
                const currentY = e.touches[0].clientY;
                const currentX = e.touches[0].clientX;
                const deltaY = currentY - touchStartY; // Moved down = positive delta
                const deltaX = currentX - touchStartX;

                // Drag threshold to start scrolling (avoid tap jitter)
                if (!isScrolling && (Math.abs(deltaY) > 8 || Math.abs(deltaX) > 8)) {
                    isScrolling = true;
                }

                if (isScrolling) {
                    const stepY = currentY - touchStartY;

                    if (Math.abs(stepY) > 2) { // 2px sensitivity
                        // Simple 1:1 mapping (or 1:2)
                        // If finger moves down (positive), we want to scroll UP (view moves down)
                        // PyAutoGUI: scroll + = up, scroll - = down
                        // So finger delta + -> scroll amount +

                        const scrollScale = 3; // 1px drag = 3 scroll units
                        const scrollVal = Math.round(stepY * scrollScale);

                        if (scrollVal !== 0) {
                            sendScrollAtPosition(scrollVal, currentX, currentY);
                            // Update last position to current
                            touchStartY = currentY;
                            touchStartX = currentX;
                        }
                    }
                }
            }
        }, { passive: false });

        screen.addEventListener('touchend', async (e) => {
            e.preventDefault();

            if (isPinching) {
                isPinching = false;
                return;
            }

            if (isScrolling) {
                // Scrolling ended.
                // Could implement momentum here if needed.
                isScrolling = false;
                return;
            }

            // If NOT scrolling (tap)
            const now = Date.now();
            // Check for double tap
            const tapDistance = Math.hypot(touchStartX - lastTapX, touchStartY - lastTapY);
            if (now - lastTapTime < 300 && tapDistance < 30) {
                // Double Tap = Right Click
                if (navigator.vibrate) navigator.vibrate(50);
                showTouchRipple(touchStartX, touchStartY);
                addLog(`å³é”® (${touchStartX | 0}, ${touchStartY | 0})`);
                try {
                    await fetch(`${API}/interact`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ action: 'right_click', x: touchStartX, y: touchStartY })
                    });
                } catch (e) { }
                lastTapTime = 0; // Reset
            } else {
                // Single Tap -> Click
                // Update last tap
                lastTapTime = now;
                lastTapX = touchStartX;
                lastTapY = touchStartY;

                // Perform click
                if (navigator.vibrate) navigator.vibrate(10);
                showTouchRipple(touchStartX, touchStartY);

                // Adjust coordinates
                const rect = screen.getBoundingClientRect();
                const scaleX = screen.naturalWidth / rect.width;
                const scaleY = screen.naturalHeight / rect.height;
                const x = Math.round((touchStartX - rect.left) * scaleX);
                const y = Math.round((touchStartY - rect.top) * scaleY);

                addLog(`ç‚¹å‡» (${x}, ${y})`);
                try {
                    await fetch(`${API}/interact`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ action: 'click', x, y })
                    });
                } catch (e) {
                    addLog('ç‚¹å‡»å¤±è´¥: ' + e, true);
                }
            }
        });

        // Helper: Scroll at specific screen position (for touch accuracy)
        async function sendScrollAtPosition(amount, screenX, screenY) {
            const rect = screen.getBoundingClientRect();
            const scaleX = screen.naturalWidth / rect.width;
            const scaleY = screen.naturalHeight / rect.height;
            // Convert screen coordinates to window coordinates
            // Note: clientX/Y are relative to viewport. rect is relative to viewport.
            // touchStartX is clientX.

            const x = Math.round((screenX - rect.left) * scaleX);
            const y = Math.round((screenY - rect.top) * scaleY);

            // Limit x, y to image bounds? No, server handles it?
            // Just ensure >= 0

            try {
                await fetch(`${API}/interact`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'scroll', x: Math.max(0, x), y: Math.max(0, y), text: String(amount) })
                });
            } catch (e) {
                // console.log('Scroll error', e);
            }
        }

        // Legacy scroll at center (for buttons)
        async function sendScrollAmount(amount) {
            const rect = screen.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            await sendScrollAtPosition(amount, centerX, centerY);
        }

        // Visual touch feedback
        function showTouchRipple(x, y) {
            const ripple = document.createElement('div');
            ripple.style.cssText = `
                position: fixed;
                left: ${x - 20}px;
                top: ${y - 20}px;
                width: 40px;
                height: 40px;
                border-radius: 50%;
                background: rgba(0, 217, 255, 0.5);
                pointer-events: none;
                animation: ripple 0.4s ease-out;
            `;
            document.body.appendChild(ripple);
            setTimeout(() => ripple.remove(), 400);
        }

        // Mouse wheel scroll on screen
        screen.addEventListener('wheel', async (e) => {
            e.preventDefault();
            const rect = screen.getBoundingClientRect();
            const scaleX = screen.naturalWidth / rect.width;
            const scaleY = screen.naturalHeight / rect.height;
            const x = Math.round((e.clientX - rect.left) * scaleX);
            const y = Math.round((e.clientY - rect.top) * scaleY);
            const amount = e.deltaY > 0 ? -3 : 3; // Scroll direction

            try {
                await fetch(`${API}/interact`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'scroll', x, y, text: String(amount) })
                });
            } catch (e) {
                console.log('Scroll error', e);
            }
        }, { passive: false });

        // Auto-connect
        setTimeout(connect, 500);
    </script>
</body>

</html>